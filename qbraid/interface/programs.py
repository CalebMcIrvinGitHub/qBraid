# Copyright (C) 2023 qBraid
#
# This file is part of the qBraid-SDK
#
# The qBraid-SDK is free software released under the GNU General Public License v3
# or later. You can redistribute and/or modify it under the terms of the GPL v3.
# See the LICENSE file in the project root or <https://www.gnu.org/licenses/gpl-3.0.html>.
#
# THERE IS NO WARRANTY for the qBraid-SDK, as per Section 15 of the GPL v3.

"""
Module containing quantum programs used for testing

"""
from typing import TYPE_CHECKING, Any, Callable, Dict, Optional, Tuple

import numpy as np

from qbraid._qprogram import QPROGRAM, QPROGRAM_LIBS
from qbraid.exceptions import PackageValueError

from .calculate_unitary import to_unitary

QROGRAM_TEST_TYPE = Tuple[Dict[str, Callable[[Any], QPROGRAM]], np.ndarray]

if TYPE_CHECKING:
    import qbraid

# pylint: disable=import-outside-toplevel


def bell_data() -> QROGRAM_TEST_TYPE:
    """Returns bell circuit/program in each supported package."""
    from qbraid.interface.qbraid_braket.circuits import braket_bell
    from qbraid.interface.qbraid_cirq.circuits import cirq_bell
    from qbraid.interface.qbraid_pyquil.programs import pyquil_bell
    from qbraid.interface.qbraid_pytket.circuits import pytket_bell
    from qbraid.interface.qbraid_qasm.circuits import qasm_bell
    from qbraid.interface.qbraid_qiskit.circuits import qiskit_bell

    unitary = to_unitary(cirq_bell())

    circuits = {
        "braket": braket_bell,
        "cirq": cirq_bell,
        "pyquil": pyquil_bell,
        "qiskit": qiskit_bell,
        "pytket": pytket_bell,
        "qasm": qasm_bell,
    }

    return circuits, unitary


def shared15_data() -> QROGRAM_TEST_TYPE:
    """Returns shared gates circuit/program in each supported package."""
    from qbraid.interface.qbraid_braket.circuits import braket_shared15
    from qbraid.interface.qbraid_cirq.circuits import cirq_shared15
    from qbraid.interface.qbraid_pytket.circuits import pytket_shared15
    from qbraid.interface.qbraid_qasm.circuits import qasm_shared15
    from qbraid.interface.qbraid_qiskit.circuits import qiskit_shared15

    unitary = to_unitary(cirq_shared15())

    circuits = {
        "braket": braket_shared15,
        "cirq": cirq_shared15,
        "qiskit": qiskit_shared15,
        "pytket": pytket_shared15,
        "qasm": qasm_shared15,
    }

    return circuits, unitary


def random_circuit(
    package: str = "qasm", num_qubits: Optional[int] = None, depth: Optional[int] = None, max_operands:Optional[int] = None, seed = None, measure=False, **kwargs
) -> "qbraid.QPROGRAM":
    """Generate random circuit of arbitrary size and form.

    Args:
        package: qBraid supported software package
        num_qubits: Number of quantum wires. If not provided, set randomly in range [2,4].
        depth: Layers of operations (i.e. critical path length)
            If not provided, set randomly in range [2,4].

    Raises:
        PackageValueError: if ``package`` is not supported
        QbraidError: when invalid random circuit options given

    Returns:
        :data:`~qbraid.QPROGRAM`: randomly generated quantum circuit/program

    """
    # todo: custom random gate
    if package not in QPROGRAM_LIBS:
        raise PackageValueError(package)
    num_qubits = np.random.randint(1, 4) if num_qubits is None else num_qubits
    depth = np.random.randint(1, 4) if depth is None else depth
    max_operands = np.random.randint(1, 3) if max_operands is None else max_operands
    if package == "qasm":
        
        if seed is None:
            seed = np.random.randint(0, np.iinfo(np.int32).max)
        rng = np.random.default_rng(seed)
        #create random circuit qasm3.0
        qasm_code_header = f"""
// Random Circuit generated by qBraid
OPENQASM 3.0;
include "stdgates.inc";
/*
    seed = {seed}
    num_qubits = {num_qubits}
    depth = {depth}
    max_operands = {max_operands}
*/
"""
        if num_qubits==0:
            rand_circuit = qasm_code_header
        else:
            rand_circuit = qasm_code_header + f"qubit[{num_qubits}] q;\n"
        if measure:
            rand_circuit += f"bit[{num_qubits}] c;\n"
        

        q1_gates = [("id",1,0),
                    ("x",1,0),
                    ("y",1,0), 
                    ("z",1,0), 
                    ("h",1,0), 
                    ("s",1,0), 
                    ("t",1,0),
                    ("sdg",1,0), 
                    ("tdg",1,0),
                    ("sx",1,0), 
                    ("rx",1,1), 
                    ("ry",1,1), 
                    ("rz",1,1), 
                    ("p",1,1),
                    ("u1",1,1),
                    ("u2",1,2),
                    ("u3",1,3),
                    ("reset",1,0)
                    ]
        
        q2_gates = [("cx",2,0),
                    ("cy",2,0),
                    ("cz",2,0),
                    ("ch",2,0),
                    ("cp",2,1),
                    ("crx",2,1),
                    ("cry",2,1),
                    ("crz",2,1),
                    ("swap",2,0),
                    ("cu",2,4)
                    ]
        
        q3_gates = [("ccx",3,0),
                    ("cswap",3,0)
                    ]
                    
        gates=q1_gates.copy()
        max_operands = min(max_operands, num_qubits)
        if max_operands >= 2:
            gates.extend(q2_gates)
        if max_operands >= 3:
            gates.extend(q3_gates)
        gates = np.array(gates, dtype=[("gate", object), ("num_qubits", np.int64), ("num_params", np.int64)])
        qubits=np.arange(num_qubits)
        for _ in range(depth):
            gate_specs = rng.choice(gates, size=num_qubits)
            cumulative_qubits = np.cumsum(gate_specs["num_qubits"], dtype=np.int64)
            
            max_index = np.searchsorted(cumulative_qubits, num_qubits, side="right")
            gate_specs = gate_specs[:max_index]
            slack = num_qubits - cumulative_qubits[max_index - 1]
            if slack:
                
                gates = np.array(q1_gates, dtype=[("gate", object), ("num_qubits", np.int64), ("num_params", np.int64)])
                k=rng.choice(gates, size=slack)
                gate_specs = np.hstack((gate_specs, k))
            
            q_indices = np.empty(len(gate_specs) + 1, dtype=np.int64)
            p_indices = np.empty(len(gate_specs) + 1, dtype=np.int64)
            q_indices[0] = p_indices[0] = 0
            np.cumsum(gate_specs["num_qubits"], out=q_indices[1:])
            np.cumsum(gate_specs["num_params"], out=p_indices[1:])
            parameters = rng.uniform(0, 2 * np.pi, size=p_indices[-1])
            for i, (gate, q, p) in enumerate(gate_specs):
                
                if p:
                    rand_circuit += f"{gate}({','.join([str(parameters[j]) for j in range(p_indices[i], p_indices[i + 1])])}) {','.join([f'q[{qubits[j]}]' for j in range(q_indices[i], q_indices[i + 1])])};\n"
                else:
                    rand_circuit += f"{gate} {','.join([f'q[{qubits[j]}]' for j in range(q_indices[i], q_indices[i + 1])])};\n"
            qubits = rng.permutation(qubits)
        if measure:
            for i in range(num_qubits):
                rand_circuit += f"c[{i}] = measure q[{i}];\n"
    
    elif package == "qiskit":
        from qbraid.interface.qbraid_qiskit.circuits import _qiskit_random

        rand_circuit = _qiskit_random(num_qubits, depth, **kwargs)
    elif package == "cirq":
        from qbraid.interface.qbraid_cirq.circuits import _cirq_random

        rand_circuit = _cirq_random(num_qubits, depth, **kwargs)

    else:
        from qbraid import circuit_wrapper
        rand_circuit = circuit_wrapper(rand_circuit).transpile(package)   
    return rand_circuit